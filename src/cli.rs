use {
  crate::primitives::{Keypair, Pubkey},
  clap::Parser,
  libp2p::{multiaddr::Protocol, Multiaddr},
  std::{
    net::{IpAddr, SocketAddr},
    path::PathBuf,
  },
};

#[derive(Debug, Parser)]
#[clap(name = "Inter-Relay Network", version)]
pub struct CliOpts {
  #[clap(short, long, help = "relay network identifier, e.g. irn-prod-1")]
  pub network_id: String,

  #[clap(
    short,
    long,
    default_value_t = Keypair::unique(),
    help = "specifies a static secret key of the node account")]
  pub secret: Keypair,

  #[clap(
    short,
    long,
    parse(from_occurrences),
    help = "Use verbose output (-vv very verbose output)"
  )]
  pub verbose: u64,

  #[clap(
    long,
    help = "address of a known peer to bootstrap p2p networking from"
  )]
  peer: Vec<SocketAddr>,

  #[clap(long, help = "listen address of the node", default_value = "0.0.0.0")]
  addr: Vec<IpAddr>,

  #[clap(long, help = "listen port of the node", default_value = "44668")]
  port: u16,

  #[clap(long, help = "port on which RPC API service is exposed")]
  rpc: Option<u16>,

  #[clap(
    long,
    parse(from_os_str),
    help = "path to the data directory",
    default_value = "~/.walletconnect/"
  )]
  data_dir: PathBuf,
}

impl CliOpts {
  /// Lists all the multiaddresses this node will listen
  /// on for incoming connections. By default it will listen
  /// on all available interfaces.
  pub fn listen_multiaddrs(&self) -> Vec<Multiaddr> {
    self
      .addr
      .iter()
      .map(|addr| {
        let mut maddr = Multiaddr::empty();
        maddr.push(match *addr {
          IpAddr::V4(addr) => Protocol::Ip4(addr),
          IpAddr::V6(addr) => Protocol::Ip6(addr),
        });
        maddr.push(Protocol::Tcp(self.port));
        maddr
      })
      .collect()
  }

  /// Lists all multiaddresses of known peers.
  /// Those peers are used as first bootstrap nodes to join
  /// the p2p gossip network.
  pub fn peers(&self) -> Vec<Multiaddr> {
    self
      .peer
      .iter()
      .map(|addr| {
        let mut maddr = Multiaddr::empty();
        maddr.push(match *addr {
          SocketAddr::V4(addr) => Protocol::Ip4(*addr.ip()),
          SocketAddr::V6(addr) => Protocol::Ip6(*addr.ip()),
        });
        maddr.push(Protocol::Tcp(addr.port()));
        maddr
      })
      .collect()
  }

  /// Retreives the public key of the current node.
  ///
  /// This key can either be statically set during startup or
  /// a new unique ed25519 key gets generated by default if none
  /// is provided.
  pub fn identity(&self) -> Pubkey {
    self.secret.public()
  }

  /// The libp2p identity of this relayer node.
  /// This is based on the keypair provided through [`self.secret`]
  pub fn p2p_identity(&self) -> libp2p::identity::Keypair {
    libp2p::identity::Keypair::Ed25519(
      libp2p::identity::ed25519::SecretKey::from_bytes(
        &mut self.secret.secret().to_bytes(),
      )
      .unwrap()
      .into(),
    )
  }

  /// If an RPC port is provided provided, returns all socketaddrs on which
  /// the RPC API service will be listening on incoming JSON-RPC calls from
  /// external clients.
  pub fn rpc_endpoints(&self) -> Option<Vec<SocketAddr>> {
    self.rpc.map(|port| {
      self
        .addr
        .iter()
        .cloned()
        .map(|addr| SocketAddr::new(addr, port))
        .collect()
    })
  }

  /// Gets the data directory for the this chain.
  /// The chain directory is <top-level-data-dir>/<chain-id>/*
  pub fn data_dir(&self) -> Result<PathBuf, std::io::Error> {
    let mut dir: PathBuf = shellexpand::full(self.data_dir.to_str().unwrap())
      .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidInput, e))?
      .to_string()
      .into();
    dir.push(&self.network_id);
    std::fs::create_dir_all(dir.clone())?;
    Ok(dir)
  }
}
